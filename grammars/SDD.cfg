Program -> { env = neww Env(); }
           Stmts

Stmts -> Stmt Stmts
         {
           Stmts *stmts = new Stmts();
           e_stack->push(Element(stmts));
         }

Stmts -> Epsilon
         {
           Stmts *stmts = new Stmts();
           e_stack->push(Element(stmts));
         }

Stmt -> TYPE ID ;
        { 
          if(env->find(ID.lexeme)) {
            error("redefination of " + ID.lexeme);
            return false;
          }
          env->put(ID.lexeme, TYPE);  
          Stmt *stmt = new Stmt();
          STACK_POP(2);
          e_stack->top().Set_ele(stmt));
        }

Stmt -> TYPE ID = Expr ;
        {
          if(env->find(ID.lexeme)) {
            error("redefination of " + ID.lexeme);
            return false;
          }
          env->put(ID.lexeme, TYPE);

          ENTRY entry;
          if(1.type != 4.type) {
            entry = NEW_ENTRY;
            gen(entry '=' type_tranform(4.type, 1.type)
                + 4.entry);
          }
          if(entry == "") entry = Expr.entry;
          gen(ID.lexeme '=' entry);
          
          Stmt *stmt = new Stmt();
          STACK_POP(4);
          e_stack->top().Set_ele(stmt);
        }

Stmt -> ID = Expr ;
        {
          Id *p = env->get(ID.lexeme);
          if(p == NULL) {
            error(ID.lexeme + " doesn't exist!");
            return false;
          }
          
          ENTRY entry;
          if(1.type != 3.type) {
            entry = NEW_ENTRY;
            gen(entry '=' type_tranform(3.type, 1.type)
                + 3.entry);
          }
          gen(p->name '=' entry);
          
          Stmt *stmt = new Stmt();
          STACK_POP(3);
          e_stack->top().Set_ele(stmt);
        }

Expr -> Expr + Term
        { 
          ENTRY entry;
          TAG type_tag;
          if(1.type != 3.type) {
            entry = NEW_ENTRY;
            # float > int
            type_tag = max(1.type, 3.type);
            if(1.type != type_tag) {
              gen(entry '=' type_transform(1.type, type_tag)
                  + 1.entry);
            } else {
              gen(entry '=' type_transform(3.type, type_tag)
                  + 3.entry);
            }
          }
          Expr *expr =
            new Expr(NEW_ENTRY, Env->Type(type_tag));
          gen(0.entry '=' 1.entry '+' 3.entry);
        }

Expr -> Expr - Term
        { 
          ENTRY entry;
          TAG type_tag;
          if(1.type != 3.type) {
            entry = NEW_ENTRY;
            # float > int
            type_tag = max(1.type, 3.type);
            if(1.type != type_tag) {
              gen(entry '=' type_transform(1.type, type_tag)
                  + 1.entry);
            } else {
              gen(entry '=' type_transform(3.type, type_tag)
                  + 3.entry);
            }
          }
          Expr *expr =
            new Expr(NEW_ENTRY, Env->Type(type_tag));
          gen(0.entry '=' 1.entry '-' 3.entry);
        }

Expr -> Term
        { 
          0 = new Expr(1);
        }

Term -> Term * Unary
        { 
          ENTRY entry;
          TAG type_tag;
          if(1.type != 3.type) {
            entry = NEW_ENTRY;
            # float > int
            type_tag = max(1.type, 3.type);
            if(1.type != type_tag) {
              gen(entry '=' type_transform(1.type, type_tag)
                  + 1.entry);
            } else {
              gen(entry '=' type_transform(3.type, type_tag)
                  + 3.entry);
            }
          }
          Term *term =
            new Term(NEW_ENTRY, Env->Type(type_tag));
          gen(0.entry '=' 1.entry '*' 2.entry);
        }

Term -> Term / Unary
        { 
          ENTRY entry;
          TAG type_tag;
          if(1.type != 3.type) {
            entry = NEW_ENTRY;
            # float > int
            type_tag = max(1.type, 3.type);
            if(1.type != type_tag) {
              gen(entry '=' type_transform(1.type, type_tag)
                  + 1.entry);
            } else {
              gen(entry '=' type_transform(3.type, type_tag)
                  + 3.entry);
            }
          }
          Expr *expr =
            new Expr(NEW_ENTRY, Env->Type(type_tag));
          gen(0.entry '=' 1.entry '/' 2.entry);
        }

Term -> Unary
        {
          0 = new Term(Unary);
        }

Unary -> - Unary
        { 
          0.entry = new Entry();
          gen(0.entry '=' 'minus' 2.entry);
        }

Unary -> Factor
        {
          0 = new Unary(1);
        }

Factor -> ( Expr )
        { 
          0 = new Factor(1);
        }

Factor -> ID
        {
          Id *p = env->Get(ID.lexeme);
          if(p == NULL) {
            error(p->name + 'is not defined' );
            return false;
          }
          0 = new Factor(p);
        }

Factor -> INTEGER
        {
          0 = new Factor(1);
        }

Factor -> FLOAT
        {
          0 = new Factor(1);
        }
